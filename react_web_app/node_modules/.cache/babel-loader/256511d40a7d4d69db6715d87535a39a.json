{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar events = require('events');\n\nvar Store = require('./store');\n\nvar eos = require('end-of-stream');\n\nvar mqttPacket = require('mqtt-packet');\n\nvar Writable = require('readable-stream').Writable;\n\nvar inherits = require('inherits');\n\nvar reInterval = require('reinterval');\n\nvar validations = require('./validations');\n\nvar xtend = require('xtend');\n\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback);\n};\n\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\n\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction sendPacket(client, packet, cb) {\n  client.emit('packetsend', packet);\n  var result = mqttPacket.writeToStream(packet, client.stream);\n\n  if (!result && cb) {\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    cb();\n  }\n}\n\nfunction flush(queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId] === 'function') {\n        queue[messageId](new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction storeAndSend(client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop() {}\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\n\n\nfunction MqttClient(streamBuilder, options) {\n  var k;\n  var that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {}; // Defaults\n\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  this.options.clientId = typeof this.options.clientId === 'string' ? this.options.clientId : defaultId();\n  this.streamBuilder = streamBuilder; // Inflight message storages\n\n  this.outgoingStore = this.options.outgoingStore || new Store();\n  this.incomingStore = this.options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero; // map of subscribed topics to support reconnection\n\n  this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n  this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n  this.pingTimer = null; // Is the client connected?\n\n  this.connected = false; // Are we disconnecting?\n\n  this.disconnecting = false; // Packet queue\n\n  this.queue = []; // connack timer\n\n  this.connackTimer = null; // Reconnect timer\n\n  this.reconnectTimer = null;\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535)); // Inflight callbacks\n\n  this.outgoing = {}; // Mark connected on connect\n\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return;\n    }\n\n    this.connected = true;\n    var outStore = this.outgoingStore.createStream();\n    this.once('close', remove);\n    outStore.on('end', function () {\n      that.removeListener('close', remove);\n    });\n    outStore.on('error', function (err) {\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n    }\n\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n\n      var packet = outStore.read(1);\n      var cb;\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      } // Avoid unnecessary stream read operations when disconnected\n\n\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId];\n\n        that.outgoing[packet.messageId] = function (err, status) {\n          // Ensure that the original callback passed in to publish gets invoked\n          if (cb) {\n            cb(err, status);\n          }\n\n          storeDeliver();\n        };\n\n        that._sendPacket(packet);\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    } // start flowing\n\n\n    storeDeliver();\n  }); // Mark disconnected on stream close\n\n  this.on('close', function () {\n    this.connected = false;\n    clearTimeout(this.connackTimer);\n  }); // Setup ping timer\n\n  this.on('connect', this._setupPingTimer); // Send queued packets\n\n  this.on('connect', function () {\n    var queue = this.queue;\n\n    function deliver() {\n      var entry = queue.shift();\n      var packet = null;\n\n      if (!entry) {\n        return;\n      }\n\n      packet = entry.packet;\n\n      that._sendPacket(packet, function (err) {\n        if (entry.cb) {\n          entry.cb(err);\n        }\n\n        deliver();\n      });\n    }\n\n    deliver();\n  });\n  var firstConnection = true; // resubscribe\n\n  this.on('connect', function () {\n    if (!firstConnection && this.options.clean && Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      } else {\n        this._resubscribeTopics = {};\n      }\n    }\n\n    firstConnection = false;\n  }); // Clear ping timer\n\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n  }); // Setup reconnect timer on disconnect\n\n  this.on('close', this._setupReconnect);\n  events.EventEmitter.call(this);\n\n  this._setupStream();\n}\n\ninherits(MqttClient, events.EventEmitter);\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\n\nMqttClient.prototype._setupStream = function () {\n  var connectPacket;\n  var that = this;\n  var writable = new Writable();\n  var parser = mqttPacket.parser(this.options);\n  var completeParse = null;\n  var packets = [];\n\n  this._clearReconnect();\n\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    packets.push(packet);\n  });\n\n  function nextTickWork() {\n    process.nextTick(work);\n  }\n\n  function work() {\n    var packet = packets.shift();\n    var done = completeParse;\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      completeParse = null;\n      done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    parser.parse(buf);\n    work();\n  };\n\n  this.stream.pipe(writable); // Suppress connection errors\n\n  this.stream.on('error', nop); // Echo stream close\n\n  eos(this.stream, this.emit.bind(this, 'close')); // Send a connect packet\n\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect'; // avoid message queue\n\n  sendPacket(this, connectPacket); // Echo connection errors\n\n  parser.on('error', this.emit.bind(this, 'error')); // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet);\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n\n      break;\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n\n      done();\n      break;\n\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n\n      break;\n\n    case 'connack':\n      this._handleConnack(packet);\n\n      done();\n      break;\n\n    case 'pingresp':\n      this._handlePingresp(packet);\n\n      done();\n      break;\n\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n\n  return this.disconnecting;\n};\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\n\n\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet; // .publish(topic, payload, cb);\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  } // default opts\n\n\n  var defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  };\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop;\n\n      this._sendPacket(packet);\n\n      break;\n\n    default:\n      this._sendPacket(packet, callback);\n\n      break;\n  }\n\n  return this;\n};\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.subscribe = function () {\n  var packet;\n  var args = Array.prototype.slice.call(arguments);\n  var subs = [];\n  var obj = args.shift();\n  var resubscribe = obj.resubscribe;\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n  var invalidTopic;\n  var that = this;\n  delete obj.resubscribe;\n\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  invalidTopic = validations.validateTopics(obj);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  var defaultOpts = {\n    qos: 0\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos || !that._resubscribeTopics.hasOwnProperty(topic) || resubscribe) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        });\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      if (that._resubscribeTopics[k] < obj[k] || !that._resubscribeTopics.hasOwnProperty(k) || resubscribe) {\n        subs.push({\n          topic: k,\n          qos: obj[k]\n        });\n      }\n    });\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n\n  if (!subs.length) {\n    callback(null, []);\n    return;\n  } // subscriptions to resubscribe to in case of disconnect\n\n\n  if (this.options.resubscribe) {\n    var topics = [];\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos;\n        topics.push(sub.topic);\n      }\n    });\n    that.messageIdToTopic[packet.messageId] = topics;\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted;\n\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i];\n      }\n    }\n\n    callback(err, subs);\n  };\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n  var that = this;\n  callback = callback || nop;\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic];\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic;\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic];\n    });\n  }\n\n  this.outgoing[packet.messageId] = callback;\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\n\n\nMqttClient.prototype.end = function (force, cb) {\n  var that = this;\n\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n\n  function closeStores() {\n    that.disconnected = true;\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments);\n        }\n\n        that.emit('end');\n      });\n    });\n\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores));\n  }\n\n  if (this.disconnecting) {\n    return this;\n  }\n\n  this._clearReconnect();\n\n  this.disconnecting = true;\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    finish();\n  }\n\n  return this;\n};\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\n\n\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid];\n  delete this.outgoing[mid];\n  this.outgoingStore.del({\n    messageId: mid\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\n\n\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this;\n\n  var f = function f() {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n\n    that._reconnect();\n  };\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n\n  return this;\n};\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\n\n\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect');\n\n  this._setupStream();\n};\n/**\n * _setupReconnect - setup reconnect timer\n */\n\n\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      this.emit('offline');\n      this.reconnecting = true;\n    }\n\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  }\n};\n/**\n * _clearReconnect - clear the reconnect timer\n */\n\n\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\n\n\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done);\n  }\n\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n\n    this.stream.destroy();\n  } else {\n    this._sendPacket({\n      cmd: 'disconnect'\n    }, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect();\n\n    this._setupReconnect();\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\n\n\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n      this.queue.push({\n        packet: packet,\n        cb: cb\n      });\n    } else if (packet.qos > 0) {\n      cb = this.outgoing[packet.messageId];\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err);\n        }\n      });\n    } else if (cb) {\n      cb(new Error('No connection to broker'));\n    }\n\n    return;\n  } // When sending a packet, reschedule the ping timer\n\n\n  this._shiftPingInterval();\n\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n\n    case 'pubrel':\n      storeAndSend(this, packet, cb);\n      return;\n\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb);\n      break;\n\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n\n    case 0:\n    /* falls through */\n\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n};\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\n\n\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\n\n\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\n\n\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false;\n\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true);\n  }\n};\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\n\n\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode;\n  var errors = ['', 'Unacceptable protocol version', 'Identifier rejected', 'Server unavailable', 'Bad username or password', 'Not authorized'];\n  clearTimeout(this.connackTimer);\n\n  if (rc === 0) {\n    this.reconnecting = false;\n    this.emit('connect', packet);\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\n\n\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop;\n  var topic = packet.topic.toString();\n  var message = packet.payload;\n  var qos = packet.qos;\n  var mid = packet.messageId;\n  var that = this;\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function (err) {\n        if (err) {\n          return done(err);\n        }\n\n        that._sendPacket({\n          cmd: 'pubrec',\n          messageId: mid\n        }, done);\n      });\n      break;\n\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done(err);\n        } // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n\n\n        that._sendPacket({\n          cmd: 'puback',\n          messageId: mid\n        }, done);\n      });\n      break;\n\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\n\n\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId;\n  var type = packet.cmd;\n  var response = null;\n  var cb = this.outgoing[mid];\n  var that = this;\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return;\n  } // Process\n\n\n  switch (type) {\n    case 'pubcomp': // same thing as puback for QoS 2\n\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      };\n\n      this._sendPacket(response);\n\n      break;\n\n    case 'suback':\n      delete this.outgoing[mid];\n\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid];\n\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic];\n          });\n        }\n      }\n\n      cb(null, packet);\n      break;\n\n    case 'unsuback':\n      delete this.outgoing[mid];\n      cb(null);\n      break;\n\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  var mid = packet.messageId;\n  var that = this;\n  var comp = {\n    cmd: 'pubcomp',\n    messageId: mid\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.incomingStore.put(packet, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        that.handleMessage(pub, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          that._sendPacket(comp, callback);\n        });\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n/**\n * _nextId\n * @return unsigned int\n */\n\n\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++; // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n\n  if (this.nextId === 65536) {\n    this.nextId = 1;\n  }\n\n  return id;\n};\n/**\n * getLastMessageId\n * @return unsigned int\n */\n\n\nMqttClient.prototype.getLastMessageId = function () {\n  return this.nextId === 1 ? 65535 : this.nextId - 1;\n};\n\nmodule.exports = MqttClient;","map":{"version":3,"sources":["/Users/neythen/Desktop/Projects/LED_paint/react_web_app/node_modules/mqtt-react/node_modules/mqtt/lib/client.js"],"names":["events","require","Store","eos","mqttPacket","Writable","inherits","reInterval","validations","xtend","setImmediate","global","callback","process","nextTick","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","defaultId","Math","random","toString","substr","sendPacket","client","packet","cb","emit","result","writeToStream","stream","once","flush","queue","Object","keys","forEach","messageId","Error","storeAndSend","outgoingStore","put","storedPacket","err","nop","MqttClient","streamBuilder","options","k","that","clientId","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","nextId","max","floor","outgoing","on","disconnected","outStore","createStream","remove","removeListener","destroy","storeDeliver","read","status","_sendPacket","clearTimeout","_setupPingTimer","deliver","entry","shift","firstConnection","length","subscribe","clear","_setupReconnect","EventEmitter","call","_setupStream","prototype","connectPacket","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","work","done","_handlePacket","_write","buf","enc","parse","pipe","bind","create","cmd","setMaxListeners","setTimeout","_cleanUp","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_checkDisconnecting","publish","topic","message","opts","defaultOpts","qos","retain","dup","payload","_nextId","args","Array","slice","arguments","subs","obj","pop","invalidTopic","validateTopics","isArray","hasOwnProperty","subscriptions","topics","sub","granted","i","unsubscribe","unsubscriptions","end","force","closeStores","close","apply","_deferredReconnect","finish","removeOutgoingMessage","mid","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","_shiftPingInterval","pingResp","_checkPing","reschedule","rc","returnCode","errors","code","handleMessage","type","response","comp","get","pub","id","getLastMessageId","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId] === 'function') {\n        queue[messageId](new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store()\n  this.incomingStore = this.options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return\n    }\n\n    this.connected = true\n    var outStore = this.outgoingStore.createStream()\n\n    this.once('close', remove)\n    outStore.on('end', function () {\n      that.removeListener('close', remove)\n    })\n    outStore.on('error', function (err) {\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n\n      var packet = outStore.read(1)\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId]\n        that.outgoing[packet.messageId] = function (err, status) {\n          // Ensure that the original callback passed in to publish gets invoked\n          if (cb) {\n            cb(err, status)\n          }\n\n          storeDeliver()\n        }\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    // start flowing\n    storeDeliver()\n  })\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer)\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  var firstConnection = true\n  // resubscribe\n  this.on('connect', function () {\n    if (!firstConnection &&\n        this.options.clean &&\n        Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      } else {\n        this._resubscribeTopics = {}\n      }\n    }\n\n    firstConnection = false\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    process.nextTick(work)\n  }\n\n  function work () {\n    var packet = packets.shift()\n    var done = completeParse\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      completeParse = null\n      done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    work()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'))\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop\n      this._sendPacket(packet)\n      break\n    default:\n      this._sendPacket(packet, callback)\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = Array.prototype.slice.call(arguments)\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = { qos: 0 }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos ||\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\n          resubscribe) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        })\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (that._resubscribeTopics[k] < obj[k] ||\n            !that._resubscribeTopics.hasOwnProperty(k) ||\n            resubscribe) {\n          subs.push({\n            topic: k,\n            qos: obj[k]\n          })\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i]\n      }\n    }\n\n    callback(err, subs)\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n\n  callback = callback || nop\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  this.outgoing[packet.messageId] = callback\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this\n\n  if (typeof force === 'function') {\n    cb = force\n    force = false\n  }\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments)\n        }\n        that.emit('end')\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid]\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    this.stream.destroy()\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n      this.queue.push({ packet: packet, cb: cb })\n    } else if (packet.qos > 0) {\n      cb = this.outgoing[packet.messageId]\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err)\n        }\n      })\n    } else if (cb) {\n      cb(new Error('No connection to broker'))\n    }\n\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode\n  var errors = [\n    '',\n    'Unacceptable protocol version',\n    'Identifier rejected',\n    'Server unavailable',\n    'Bad username or password',\n    'Not authorized'\n  ]\n\n  clearTimeout(this.connackTimer)\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this.emit('connect', packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n      })\n      break\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\n      })\n      break\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid]\n  var that = this\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n\n      this._sendPacket(response)\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid]\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic]\n          })\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.incomingStore.put(packet, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.handleMessage(pub, function (err) {\n          if (err) {\n            return callback(err)\n          }\n          that._sendPacket(comp, callback)\n        })\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\nmodule.exports = MqttClient\n"]},"metadata":{},"sourceType":"script"}